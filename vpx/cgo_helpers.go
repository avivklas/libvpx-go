// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 06 Jan 2016 08:14:46 MSK.
// By http://git.io/cgogen. DO NOT EDIT.

package vpx

/*
#cgo pkg-config: vpx
#include <vpx/vp8.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocVp8PostprocCfgMemory allocates memory for type C.vp8_postproc_cfg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVp8PostprocCfgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVp8PostprocCfgValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVp8PostprocCfgValue = unsafe.Sizeof([1]C.vp8_postproc_cfg_t{})

// Ref returns a reference.
func (x *Vp8PostprocCfg) Ref() *C.vp8_postproc_cfg_t {
	if x == nil {
		return nil
	}
	return x.refc33fa674
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Vp8PostprocCfg) Free() {
	if x != nil && x.allocsc33fa674 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsc33fa674.(*cgoAllocMap).Free()
		x.refc33fa674 = nil
	}
}

// NewVp8PostprocCfgRef initialises a new struct holding the reference to the originaitng C struct.
func NewVp8PostprocCfgRef(ref *C.vp8_postproc_cfg_t) *Vp8PostprocCfg {
	if ref == nil {
		return nil
	}
	obj := new(Vp8PostprocCfg)
	obj.refc33fa674 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *Vp8PostprocCfg) {
	// 	C.free(unsafe.Pointer(x.refc33fa674))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Vp8PostprocCfg) PassRef() (ref *C.vp8_postproc_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc33fa674 != nil {
		return x.refc33fa674, nil
	}
	memc33fa674 := allocVp8PostprocCfgMemory(1)
	refc33fa674 := (*C.vp8_postproc_cfg_t)(memc33fa674)
	allocsc33fa674 := new(cgoAllocMap)
	var cpost_proc_flag_allocs *cgoAllocMap
	refc33fa674.post_proc_flag, cpost_proc_flag_allocs = (C.int)(x.PostProcFlag), cgoAllocsUnknown
	allocsc33fa674.Borrow(cpost_proc_flag_allocs)

	var cdeblocking_level_allocs *cgoAllocMap
	refc33fa674.deblocking_level, cdeblocking_level_allocs = (C.int)(x.DeblockingLevel), cgoAllocsUnknown
	allocsc33fa674.Borrow(cdeblocking_level_allocs)

	var cnoise_level_allocs *cgoAllocMap
	refc33fa674.noise_level, cnoise_level_allocs = (C.int)(x.NoiseLevel), cgoAllocsUnknown
	allocsc33fa674.Borrow(cnoise_level_allocs)

	x.refc33fa674 = refc33fa674
	x.allocsc33fa674 = allocsc33fa674
	return refc33fa674, allocsc33fa674

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Vp8PostprocCfg) PassValue() (value C.vp8_postproc_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewVp8PostprocCfgRef(nil)
	} else if x.refc33fa674 != nil {
		return *x.refc33fa674, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Vp8PostprocCfg) Deref() {
	if x.refc33fa674 == nil {
		return
	}
	x.PostProcFlag = (int)(x.refc33fa674.post_proc_flag)
	x.DeblockingLevel = (int)(x.refc33fa674.deblocking_level)
	x.NoiseLevel = (int)(x.refc33fa674.noise_level)
}

// allocRefFrameMemory allocates memory for type C.vpx_ref_frame_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRefFrameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRefFrameValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRefFrameValue = unsafe.Sizeof([1]C.vpx_ref_frame_t{})

// Ref returns a reference.
func (x *RefFrame) Ref() *C.vpx_ref_frame_t {
	if x == nil {
		return nil
	}
	return x.ref6238b069
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *RefFrame) Free() {
	if x != nil && x.allocs6238b069 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs6238b069.(*cgoAllocMap).Free()
		x.ref6238b069 = nil
	}
}

// NewRefFrameRef initialises a new struct holding the reference to the originaitng C struct.
func NewRefFrameRef(ref *C.vpx_ref_frame_t) *RefFrame {
	if ref == nil {
		return nil
	}
	obj := new(RefFrame)
	obj.ref6238b069 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *RefFrame) {
	// 	C.free(unsafe.Pointer(x.ref6238b069))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *RefFrame) PassRef() (ref *C.vpx_ref_frame_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6238b069 != nil {
		return x.ref6238b069, nil
	}
	mem6238b069 := allocRefFrameMemory(1)
	ref6238b069 := (*C.vpx_ref_frame_t)(mem6238b069)
	allocs6238b069 := new(cgoAllocMap)
	var cframe_type_allocs *cgoAllocMap
	ref6238b069.frame_type, cframe_type_allocs = (C.vpx_ref_frame_type_t)(x.FrameType), cgoAllocsUnknown
	allocs6238b069.Borrow(cframe_type_allocs)

	var cimg_allocs *cgoAllocMap
	ref6238b069.img, cimg_allocs = x.Img.PassValue()
	allocs6238b069.Borrow(cimg_allocs)

	x.ref6238b069 = ref6238b069
	x.allocs6238b069 = allocs6238b069
	return ref6238b069, allocs6238b069

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *RefFrame) PassValue() (value C.vpx_ref_frame_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewRefFrameRef(nil)
	} else if x.ref6238b069 != nil {
		return *x.ref6238b069, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *RefFrame) Deref() {
	if x.ref6238b069 == nil {
		return
	}
	x.FrameType = (RefFrameType)(x.ref6238b069.frame_type)
	x.Img = *NewImageRef(&x.ref6238b069.img)
}

// allocVp9RefFrameMemory allocates memory for type C.vp9_ref_frame_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVp9RefFrameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVp9RefFrameValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVp9RefFrameValue = unsafe.Sizeof([1]C.vp9_ref_frame_t{})

// Ref returns a reference.
func (x *Vp9RefFrame) Ref() *C.vp9_ref_frame_t {
	if x == nil {
		return nil
	}
	return x.ref223f847
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Vp9RefFrame) Free() {
	if x != nil && x.allocs223f847 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs223f847.(*cgoAllocMap).Free()
		x.ref223f847 = nil
	}
}

// NewVp9RefFrameRef initialises a new struct holding the reference to the originaitng C struct.
func NewVp9RefFrameRef(ref *C.vp9_ref_frame_t) *Vp9RefFrame {
	if ref == nil {
		return nil
	}
	obj := new(Vp9RefFrame)
	obj.ref223f847 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *Vp9RefFrame) {
	// 	C.free(unsafe.Pointer(x.ref223f847))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Vp9RefFrame) PassRef() (ref *C.vp9_ref_frame_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref223f847 != nil {
		return x.ref223f847, nil
	}
	mem223f847 := allocVp9RefFrameMemory(1)
	ref223f847 := (*C.vp9_ref_frame_t)(mem223f847)
	allocs223f847 := new(cgoAllocMap)
	var cidx_allocs *cgoAllocMap
	ref223f847.idx, cidx_allocs = (C.int)(x.Idx), cgoAllocsUnknown
	allocs223f847.Borrow(cidx_allocs)

	var cimg_allocs *cgoAllocMap
	ref223f847.img, cimg_allocs = x.Img.PassValue()
	allocs223f847.Borrow(cimg_allocs)

	x.ref223f847 = ref223f847
	x.allocs223f847 = allocs223f847
	return ref223f847, allocs223f847

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Vp9RefFrame) PassValue() (value C.vp9_ref_frame_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewVp9RefFrameRef(nil)
	} else if x.ref223f847 != nil {
		return *x.ref223f847, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Vp9RefFrame) Deref() {
	if x.ref223f847 == nil {
		return
	}
	x.Idx = (int)(x.ref223f847.idx)
	x.Img = *NewImageRef(&x.ref223f847.img)
}

// allocCodecCtxMemory allocates memory for type C.vpx_codec_ctx_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecCtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecCtxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecCtxValue = unsafe.Sizeof([1]C.vpx_codec_ctx_t{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns a reference.
func (x *CodecCtx) Ref() *C.vpx_codec_ctx_t {
	if x == nil {
		return nil
	}
	return x.ref8abc1e81
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CodecCtx) Free() {
	if x != nil && x.allocs8abc1e81 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs8abc1e81.(*cgoAllocMap).Free()
		x.ref8abc1e81 = nil
	}
}

// NewCodecCtxRef initialises a new struct holding the reference to the originaitng C struct.
func NewCodecCtxRef(ref *C.vpx_codec_ctx_t) *CodecCtx {
	if ref == nil {
		return nil
	}
	obj := new(CodecCtx)
	obj.ref8abc1e81 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *CodecCtx) {
	// 	C.free(unsafe.Pointer(x.ref8abc1e81))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CodecCtx) PassRef() (ref *C.vpx_codec_ctx_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8abc1e81 != nil {
		return x.ref8abc1e81, nil
	}
	mem8abc1e81 := allocCodecCtxMemory(1)
	ref8abc1e81 := (*C.vpx_codec_ctx_t)(mem8abc1e81)
	allocs8abc1e81 := new(cgoAllocMap)
	var cname_allocs *cgoAllocMap
	ref8abc1e81.name, cname_allocs = unpackPCharString(x.Name)
	allocs8abc1e81.Borrow(cname_allocs)

	var ciface_allocs *cgoAllocMap
	ref8abc1e81.iface, ciface_allocs = (*C.vpx_codec_iface_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Iface)).Data)), cgoAllocsUnknown
	allocs8abc1e81.Borrow(ciface_allocs)

	var cerr_allocs *cgoAllocMap
	ref8abc1e81.err, cerr_allocs = (C.vpx_codec_err_t)(x.Err), cgoAllocsUnknown
	allocs8abc1e81.Borrow(cerr_allocs)

	var cerr_detail_allocs *cgoAllocMap
	ref8abc1e81.err_detail, cerr_detail_allocs = unpackPCharString(x.ErrDetail)
	allocs8abc1e81.Borrow(cerr_detail_allocs)

	var cinit_flags_allocs *cgoAllocMap
	ref8abc1e81.init_flags, cinit_flags_allocs = (C.vpx_codec_flags_t)(x.InitFlags), cgoAllocsUnknown
	allocs8abc1e81.Borrow(cinit_flags_allocs)

	var cconfig_allocs *cgoAllocMap
	ref8abc1e81.config, cconfig_allocs = *(*[8]byte)(unsafe.Pointer(&x.Config)), cgoAllocsUnknown
	allocs8abc1e81.Borrow(cconfig_allocs)

	var cpriv_allocs *cgoAllocMap
	ref8abc1e81.priv, cpriv_allocs = (*C.vpx_codec_priv_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Priv)).Data)), cgoAllocsUnknown
	allocs8abc1e81.Borrow(cpriv_allocs)

	x.ref8abc1e81 = ref8abc1e81
	x.allocs8abc1e81 = allocs8abc1e81
	return ref8abc1e81, allocs8abc1e81

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CodecCtx) PassValue() (value C.vpx_codec_ctx_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewCodecCtxRef(nil)
	} else if x.ref8abc1e81 != nil {
		return *x.ref8abc1e81, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CodecCtx) Deref() {
	if x.ref8abc1e81 == nil {
		return
	}
	x.Name = packPCharString(x.ref8abc1e81.name)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Iface))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.ref8abc1e81.iface))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.Err = (CodecErr)(x.ref8abc1e81.err)
	x.ErrDetail = packPCharString(x.ref8abc1e81.err_detail)
	x.InitFlags = (CodecFlags)(x.ref8abc1e81.init_flags)
	x.Config = *(*[8]byte)(unsafe.Pointer(&x.ref8abc1e81.config))
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Priv))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.ref8abc1e81.priv))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

}

// allocImageMemory allocates memory for type C.vpx_image_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.vpx_image_t{})

// allocA4PUcharMemory allocates memory for type [4]*C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA4PUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA4PUcharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA4PUcharValue = unsafe.Sizeof([1][4]*C.uchar{})

// unpackA4SByte transforms a sliced Go data structure into plain C format.
func unpackA4SByte(x [4][]byte) (unpacked [4]*C.uchar, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.uchar) {
		go allocs.Free()
	})

	mem0 := allocA4PUcharMemory(1)
	allocs.Add(mem0)
	v0 := (*[4]*C.uchar)(mem0)
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uchar)(unsafe.Pointer(h.Data))
	}
	unpacked = *(*[4]*C.uchar)(mem0)
	return
}

// packA4SByte reads sliced Go data structure out from plain C format.
func packA4SByte(v *[4][]byte, ptr0 *[4]*C.uchar) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := ptr0[i0]
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff2234b.Data = uintptr(unsafe.Pointer(ptr1))
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?
	}
}

// Ref returns a reference.
func (x *Image) Ref() *C.vpx_image_t {
	if x == nil {
		return nil
	}
	return x.refc09455e3
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Image) Free() {
	if x != nil && x.allocsc09455e3 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsc09455e3.(*cgoAllocMap).Free()
		x.refc09455e3 = nil
	}
}

// NewImageRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageRef(ref *C.vpx_image_t) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.refc09455e3 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *Image) {
	// 	C.free(unsafe.Pointer(x.refc09455e3))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Image) PassRef() (ref *C.vpx_image_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc09455e3 != nil {
		return x.refc09455e3, nil
	}
	memc09455e3 := allocImageMemory(1)
	refc09455e3 := (*C.vpx_image_t)(memc09455e3)
	allocsc09455e3 := new(cgoAllocMap)
	var cfmt_allocs *cgoAllocMap
	refc09455e3.fmt, cfmt_allocs = (C.vpx_img_fmt_t)(x.Fmt), cgoAllocsUnknown
	allocsc09455e3.Borrow(cfmt_allocs)

	var ccs_allocs *cgoAllocMap
	refc09455e3.cs, ccs_allocs = (C.vpx_color_space_t)(x.Cs), cgoAllocsUnknown
	allocsc09455e3.Borrow(ccs_allocs)

	var cw_allocs *cgoAllocMap
	refc09455e3.w, cw_allocs = (C.uint)(x.W), cgoAllocsUnknown
	allocsc09455e3.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refc09455e3.h, ch_allocs = (C.uint)(x.H), cgoAllocsUnknown
	allocsc09455e3.Borrow(ch_allocs)

	var cbit_depth_allocs *cgoAllocMap
	refc09455e3.bit_depth, cbit_depth_allocs = (C.uint)(x.BitDepth), cgoAllocsUnknown
	allocsc09455e3.Borrow(cbit_depth_allocs)

	var cd_w_allocs *cgoAllocMap
	refc09455e3.d_w, cd_w_allocs = (C.uint)(x.DW), cgoAllocsUnknown
	allocsc09455e3.Borrow(cd_w_allocs)

	var cd_h_allocs *cgoAllocMap
	refc09455e3.d_h, cd_h_allocs = (C.uint)(x.DH), cgoAllocsUnknown
	allocsc09455e3.Borrow(cd_h_allocs)

	var cx_chroma_shift_allocs *cgoAllocMap
	refc09455e3.x_chroma_shift, cx_chroma_shift_allocs = (C.uint)(x.XChromaShift), cgoAllocsUnknown
	allocsc09455e3.Borrow(cx_chroma_shift_allocs)

	var cy_chroma_shift_allocs *cgoAllocMap
	refc09455e3.y_chroma_shift, cy_chroma_shift_allocs = (C.uint)(x.YChromaShift), cgoAllocsUnknown
	allocsc09455e3.Borrow(cy_chroma_shift_allocs)

	var cplanes_allocs *cgoAllocMap
	refc09455e3.planes, cplanes_allocs = unpackA4SByte(x.Planes)
	allocsc09455e3.Borrow(cplanes_allocs)

	var cstride_allocs *cgoAllocMap
	refc09455e3.stride, cstride_allocs = *(*[4]C.int)(unsafe.Pointer(&x.Stride)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cstride_allocs)

	var cbps_allocs *cgoAllocMap
	refc09455e3.bps, cbps_allocs = (C.int)(x.Bps), cgoAllocsUnknown
	allocsc09455e3.Borrow(cbps_allocs)

	var cuser_priv_allocs *cgoAllocMap
	refc09455e3.user_priv, cuser_priv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.UserPriv)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cuser_priv_allocs)

	var cimg_data_allocs *cgoAllocMap
	refc09455e3.img_data, cimg_data_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.ImgData)).Data)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cimg_data_allocs)

	var cimg_data_owner_allocs *cgoAllocMap
	refc09455e3.img_data_owner, cimg_data_owner_allocs = (C.int)(x.ImgDataOwner), cgoAllocsUnknown
	allocsc09455e3.Borrow(cimg_data_owner_allocs)

	var cself_allocd_allocs *cgoAllocMap
	refc09455e3.self_allocd, cself_allocd_allocs = (C.int)(x.SelfAllocd), cgoAllocsUnknown
	allocsc09455e3.Borrow(cself_allocd_allocs)

	var cfb_priv_allocs *cgoAllocMap
	refc09455e3.fb_priv, cfb_priv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.FbPriv)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cfb_priv_allocs)

	x.refc09455e3 = refc09455e3
	x.allocsc09455e3 = allocsc09455e3
	return refc09455e3, allocsc09455e3

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Image) PassValue() (value C.vpx_image_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewImageRef(nil)
	} else if x.refc09455e3 != nil {
		return *x.refc09455e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Image) Deref() {
	if x.refc09455e3 == nil {
		return
	}
	x.Fmt = (ImageFormat)(x.refc09455e3.fmt)
	x.Cs = (ColorSpace)(x.refc09455e3.cs)
	x.W = (uint)(x.refc09455e3.w)
	x.H = (uint)(x.refc09455e3.h)
	x.BitDepth = (uint)(x.refc09455e3.bit_depth)
	x.DW = (uint)(x.refc09455e3.d_w)
	x.DH = (uint)(x.refc09455e3.d_h)
	x.XChromaShift = (uint)(x.refc09455e3.x_chroma_shift)
	x.YChromaShift = (uint)(x.refc09455e3.y_chroma_shift)
	packA4SByte(&x.Planes, (*[4]*C.uchar)(unsafe.Pointer(&x.refc09455e3.planes)))
	x.Stride = *(*[4]int)(unsafe.Pointer(&x.refc09455e3.stride))
	x.Bps = (int)(x.refc09455e3.bps)
	x.UserPriv = (unsafe.Pointer)(unsafe.Pointer(x.refc09455e3.user_priv))
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.ImgData))
	hxff73280.Data = uintptr(unsafe.Pointer(x.refc09455e3.img_data))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.ImgDataOwner = (int)(x.refc09455e3.img_data_owner)
	x.SelfAllocd = (int)(x.refc09455e3.self_allocd)
	x.FbPriv = (unsafe.Pointer)(unsafe.Pointer(x.refc09455e3.fb_priv))
}

// allocImageRectMemory allocates memory for type C.vpx_image_rect_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageRectValue = unsafe.Sizeof([1]C.vpx_image_rect_t{})

// Ref returns a reference.
func (x *ImageRect) Ref() *C.vpx_image_rect_t {
	if x == nil {
		return nil
	}
	return x.reff3ce051f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageRect) Free() {
	if x != nil && x.allocsf3ce051f != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsf3ce051f.(*cgoAllocMap).Free()
		x.reff3ce051f = nil
	}
}

// NewImageRectRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageRectRef(ref *C.vpx_image_rect_t) *ImageRect {
	if ref == nil {
		return nil
	}
	obj := new(ImageRect)
	obj.reff3ce051f = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *ImageRect) {
	// 	C.free(unsafe.Pointer(x.reff3ce051f))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageRect) PassRef() (ref *C.vpx_image_rect_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3ce051f != nil {
		return x.reff3ce051f, nil
	}
	memf3ce051f := allocImageRectMemory(1)
	reff3ce051f := (*C.vpx_image_rect_t)(memf3ce051f)
	allocsf3ce051f := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	reff3ce051f.x, cx_allocs = (C.uint)(x.X), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	reff3ce051f.y, cy_allocs = (C.uint)(x.Y), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	reff3ce051f.w, cw_allocs = (C.uint)(x.W), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	reff3ce051f.h, ch_allocs = (C.uint)(x.H), cgoAllocsUnknown
	allocsf3ce051f.Borrow(ch_allocs)

	x.reff3ce051f = reff3ce051f
	x.allocsf3ce051f = allocsf3ce051f
	return reff3ce051f, allocsf3ce051f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageRect) PassValue() (value C.vpx_image_rect_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewImageRectRef(nil)
	} else if x.reff3ce051f != nil {
		return *x.reff3ce051f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageRect) Deref() {
	if x.reff3ce051f == nil {
		return
	}
	x.X = (uint)(x.reff3ce051f.x)
	x.Y = (uint)(x.reff3ce051f.y)
	x.W = (uint)(x.reff3ce051f.w)
	x.H = (uint)(x.reff3ce051f.h)
}

// unpackArgSCodecCtx transforms a sliced Go data structure into plain C format.
func unpackArgSCodecCtx(x []CodecCtx) (unpacked *C.vpx_codec_ctx_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vpx_codec_ctx_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCodecCtxMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vpx_codec_ctx_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vpx_codec_ctx_t)(unsafe.Pointer(h.Data))
	return
}

// packSCodecCtx reads sliced Go data structure out from plain C format.
func packSCodecCtx(v []CodecCtx, ptr0 *C.vpx_codec_ctx_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]C.vpx_codec_ctx_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCodecCtxRef(&ptr1)
	}
}

// unpackArgSImage transforms a sliced Go data structure into plain C format.
func unpackArgSImage(x []Image) (unpacked *C.vpx_image_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vpx_image_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vpx_image_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vpx_image_t)(unsafe.Pointer(h.Data))
	return
}

// packSImage reads sliced Go data structure out from plain C format.
func packSImage(v []Image, ptr0 *C.vpx_image_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]C.vpx_image_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageRef(&ptr1)
	}
}
