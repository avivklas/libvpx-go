// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Thu, 07 Jan 2016 19:56:58 MSK.
// By http://git.io/cgogen. DO NOT EDIT.

package vpx

/*
#cgo pkg-config: vpx
#include <vpx/vp8cx.h>
#include <vpx/vp8dx.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocRoiMapMemory allocates memory for type C.vpx_roi_map_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRoiMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRoiMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRoiMapValue = unsafe.Sizeof([1]C.vpx_roi_map_t{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// Ref returns a reference.
func (x *RoiMap) Ref() *C.vpx_roi_map_t {
	if x == nil {
		return nil
	}
	return x.refd53b5f78
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *RoiMap) Free() {
	if x != nil && x.allocsd53b5f78 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsd53b5f78.(*cgoAllocMap).Free()
		x.refd53b5f78 = nil
	}
}

// NewRoiMapRef initialises a new struct holding the reference to the originaitng C struct.
func NewRoiMapRef(ref *C.vpx_roi_map_t) *RoiMap {
	if ref == nil {
		return nil
	}
	obj := new(RoiMap)
	obj.refd53b5f78 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *RoiMap) {
	// 	C.free(unsafe.Pointer(x.refd53b5f78))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *RoiMap) PassRef() (ref *C.vpx_roi_map_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd53b5f78 != nil {
		return x.refd53b5f78, nil
	}
	memd53b5f78 := allocRoiMapMemory(1)
	refd53b5f78 := (*C.vpx_roi_map_t)(memd53b5f78)
	allocsd53b5f78 := new(cgoAllocMap)
	var croi_map_allocs *cgoAllocMap
	refd53b5f78.roi_map, croi_map_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.RoiMap)).Data)), cgoAllocsUnknown
	allocsd53b5f78.Borrow(croi_map_allocs)

	var crows_allocs *cgoAllocMap
	refd53b5f78.rows, crows_allocs = (C.uint)(x.Rows), cgoAllocsUnknown
	allocsd53b5f78.Borrow(crows_allocs)

	var ccols_allocs *cgoAllocMap
	refd53b5f78.cols, ccols_allocs = (C.uint)(x.Cols), cgoAllocsUnknown
	allocsd53b5f78.Borrow(ccols_allocs)

	var cdelta_q_allocs *cgoAllocMap
	refd53b5f78.delta_q, cdelta_q_allocs = *(*[4]C.int)(unsafe.Pointer(&x.DeltaQ)), cgoAllocsUnknown
	allocsd53b5f78.Borrow(cdelta_q_allocs)

	var cdelta_lf_allocs *cgoAllocMap
	refd53b5f78.delta_lf, cdelta_lf_allocs = *(*[4]C.int)(unsafe.Pointer(&x.DeltaLf)), cgoAllocsUnknown
	allocsd53b5f78.Borrow(cdelta_lf_allocs)

	var cstatic_threshold_allocs *cgoAllocMap
	refd53b5f78.static_threshold, cstatic_threshold_allocs = *(*[4]C.uint)(unsafe.Pointer(&x.StaticThreshold)), cgoAllocsUnknown
	allocsd53b5f78.Borrow(cstatic_threshold_allocs)

	x.refd53b5f78 = refd53b5f78
	x.allocsd53b5f78 = allocsd53b5f78
	return refd53b5f78, allocsd53b5f78

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *RoiMap) PassValue() (value C.vpx_roi_map_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewRoiMapRef(nil)
	} else if x.refd53b5f78 != nil {
		return *x.refd53b5f78, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *RoiMap) Deref() {
	if x.refd53b5f78 == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.RoiMap))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.refd53b5f78.roi_map))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.Rows = (uint)(x.refd53b5f78.rows)
	x.Cols = (uint)(x.refd53b5f78.cols)
	x.DeltaQ = *(*[4]int)(unsafe.Pointer(&x.refd53b5f78.delta_q))
	x.DeltaLf = *(*[4]int)(unsafe.Pointer(&x.refd53b5f78.delta_lf))
	x.StaticThreshold = *(*[4]uint)(unsafe.Pointer(&x.refd53b5f78.static_threshold))
}

// allocActiveMapMemory allocates memory for type C.vpx_active_map_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocActiveMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfActiveMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfActiveMapValue = unsafe.Sizeof([1]C.vpx_active_map_t{})

// Ref returns a reference.
func (x *ActiveMap) Ref() *C.vpx_active_map_t {
	if x == nil {
		return nil
	}
	return x.ref76943873
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ActiveMap) Free() {
	if x != nil && x.allocs76943873 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs76943873.(*cgoAllocMap).Free()
		x.ref76943873 = nil
	}
}

// NewActiveMapRef initialises a new struct holding the reference to the originaitng C struct.
func NewActiveMapRef(ref *C.vpx_active_map_t) *ActiveMap {
	if ref == nil {
		return nil
	}
	obj := new(ActiveMap)
	obj.ref76943873 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *ActiveMap) {
	// 	C.free(unsafe.Pointer(x.ref76943873))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ActiveMap) PassRef() (ref *C.vpx_active_map_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76943873 != nil {
		return x.ref76943873, nil
	}
	mem76943873 := allocActiveMapMemory(1)
	ref76943873 := (*C.vpx_active_map_t)(mem76943873)
	allocs76943873 := new(cgoAllocMap)
	var cactive_map_allocs *cgoAllocMap
	ref76943873.active_map, cactive_map_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.ActiveMap)).Data)), cgoAllocsUnknown
	allocs76943873.Borrow(cactive_map_allocs)

	var crows_allocs *cgoAllocMap
	ref76943873.rows, crows_allocs = (C.uint)(x.Rows), cgoAllocsUnknown
	allocs76943873.Borrow(crows_allocs)

	var ccols_allocs *cgoAllocMap
	ref76943873.cols, ccols_allocs = (C.uint)(x.Cols), cgoAllocsUnknown
	allocs76943873.Borrow(ccols_allocs)

	x.ref76943873 = ref76943873
	x.allocs76943873 = allocs76943873
	return ref76943873, allocs76943873

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ActiveMap) PassValue() (value C.vpx_active_map_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewActiveMapRef(nil)
	} else if x.ref76943873 != nil {
		return *x.ref76943873, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ActiveMap) Deref() {
	if x.ref76943873 == nil {
		return
	}
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.ActiveMap))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.ref76943873.active_map))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.Rows = (uint)(x.ref76943873.rows)
	x.Cols = (uint)(x.ref76943873.cols)
}

// allocScalingModeMemory allocates memory for type C.vpx_scaling_mode_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocScalingModeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfScalingModeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfScalingModeValue = unsafe.Sizeof([1]C.vpx_scaling_mode_t{})

// Ref returns a reference.
func (x *ScalingMode) Ref() *C.vpx_scaling_mode_t {
	if x == nil {
		return nil
	}
	return x.reff72a02d5
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ScalingMode) Free() {
	if x != nil && x.allocsf72a02d5 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsf72a02d5.(*cgoAllocMap).Free()
		x.reff72a02d5 = nil
	}
}

// NewScalingModeRef initialises a new struct holding the reference to the originaitng C struct.
func NewScalingModeRef(ref *C.vpx_scaling_mode_t) *ScalingMode {
	if ref == nil {
		return nil
	}
	obj := new(ScalingMode)
	obj.reff72a02d5 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *ScalingMode) {
	// 	C.free(unsafe.Pointer(x.reff72a02d5))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ScalingMode) PassRef() (ref *C.vpx_scaling_mode_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff72a02d5 != nil {
		return x.reff72a02d5, nil
	}
	memf72a02d5 := allocScalingModeMemory(1)
	reff72a02d5 := (*C.vpx_scaling_mode_t)(memf72a02d5)
	allocsf72a02d5 := new(cgoAllocMap)
	var ch_scaling_mode_allocs *cgoAllocMap
	reff72a02d5.h_scaling_mode, ch_scaling_mode_allocs = (C.VPX_SCALING_MODE)(x.HScalingMode), cgoAllocsUnknown
	allocsf72a02d5.Borrow(ch_scaling_mode_allocs)

	var cv_scaling_mode_allocs *cgoAllocMap
	reff72a02d5.v_scaling_mode, cv_scaling_mode_allocs = (C.VPX_SCALING_MODE)(x.VScalingMode), cgoAllocsUnknown
	allocsf72a02d5.Borrow(cv_scaling_mode_allocs)

	x.reff72a02d5 = reff72a02d5
	x.allocsf72a02d5 = allocsf72a02d5
	return reff72a02d5, allocsf72a02d5

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ScalingMode) PassValue() (value C.vpx_scaling_mode_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewScalingModeRef(nil)
	} else if x.reff72a02d5 != nil {
		return *x.reff72a02d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ScalingMode) Deref() {
	if x.reff72a02d5 == nil {
		return
	}
	x.HScalingMode = (ScalingModeType)(x.reff72a02d5.h_scaling_mode)
	x.VScalingMode = (ScalingModeType)(x.reff72a02d5.v_scaling_mode)
}

// allocSvcLayerIDMemory allocates memory for type C.vpx_svc_layer_id_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSvcLayerIDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSvcLayerIDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSvcLayerIDValue = unsafe.Sizeof([1]C.vpx_svc_layer_id_t{})

// Ref returns a reference.
func (x *SvcLayerID) Ref() *C.vpx_svc_layer_id_t {
	if x == nil {
		return nil
	}
	return x.refff0ac32c
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SvcLayerID) Free() {
	if x != nil && x.allocsff0ac32c != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsff0ac32c.(*cgoAllocMap).Free()
		x.refff0ac32c = nil
	}
}

// NewSvcLayerIDRef initialises a new struct holding the reference to the originaitng C struct.
func NewSvcLayerIDRef(ref *C.vpx_svc_layer_id_t) *SvcLayerID {
	if ref == nil {
		return nil
	}
	obj := new(SvcLayerID)
	obj.refff0ac32c = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *SvcLayerID) {
	// 	C.free(unsafe.Pointer(x.refff0ac32c))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SvcLayerID) PassRef() (ref *C.vpx_svc_layer_id_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff0ac32c != nil {
		return x.refff0ac32c, nil
	}
	memff0ac32c := allocSvcLayerIDMemory(1)
	refff0ac32c := (*C.vpx_svc_layer_id_t)(memff0ac32c)
	allocsff0ac32c := new(cgoAllocMap)
	var cspatial_layer_id_allocs *cgoAllocMap
	refff0ac32c.spatial_layer_id, cspatial_layer_id_allocs = (C.int)(x.SpatialLayerID), cgoAllocsUnknown
	allocsff0ac32c.Borrow(cspatial_layer_id_allocs)

	var ctemporal_layer_id_allocs *cgoAllocMap
	refff0ac32c.temporal_layer_id, ctemporal_layer_id_allocs = (C.int)(x.TemporalLayerID), cgoAllocsUnknown
	allocsff0ac32c.Borrow(ctemporal_layer_id_allocs)

	x.refff0ac32c = refff0ac32c
	x.allocsff0ac32c = allocsff0ac32c
	return refff0ac32c, allocsff0ac32c

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SvcLayerID) PassValue() (value C.vpx_svc_layer_id_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewSvcLayerIDRef(nil)
	} else if x.refff0ac32c != nil {
		return *x.refff0ac32c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SvcLayerID) Deref() {
	if x.refff0ac32c == nil {
		return
	}
	x.SpatialLayerID = (int)(x.refff0ac32c.spatial_layer_id)
	x.TemporalLayerID = (int)(x.refff0ac32c.temporal_layer_id)
}

// allocSvcRefFrameConfigMemory allocates memory for type C.vpx_svc_ref_frame_config_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSvcRefFrameConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSvcRefFrameConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSvcRefFrameConfigValue = unsafe.Sizeof([1]C.vpx_svc_ref_frame_config_t{})

// Ref returns a reference.
func (x *SvcRefFrameConfig) Ref() *C.vpx_svc_ref_frame_config_t {
	if x == nil {
		return nil
	}
	return x.ref35811db8
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SvcRefFrameConfig) Free() {
	if x != nil && x.allocs35811db8 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs35811db8.(*cgoAllocMap).Free()
		x.ref35811db8 = nil
	}
}

// NewSvcRefFrameConfigRef initialises a new struct holding the reference to the originaitng C struct.
func NewSvcRefFrameConfigRef(ref *C.vpx_svc_ref_frame_config_t) *SvcRefFrameConfig {
	if ref == nil {
		return nil
	}
	obj := new(SvcRefFrameConfig)
	obj.ref35811db8 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *SvcRefFrameConfig) {
	// 	C.free(unsafe.Pointer(x.ref35811db8))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SvcRefFrameConfig) PassRef() (ref *C.vpx_svc_ref_frame_config_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref35811db8 != nil {
		return x.ref35811db8, nil
	}
	mem35811db8 := allocSvcRefFrameConfigMemory(1)
	ref35811db8 := (*C.vpx_svc_ref_frame_config_t)(mem35811db8)
	allocs35811db8 := new(cgoAllocMap)
	var cframe_flags_allocs *cgoAllocMap
	ref35811db8.frame_flags, cframe_flags_allocs = *(*[5]C.int)(unsafe.Pointer(&x.FrameFlags)), cgoAllocsUnknown
	allocs35811db8.Borrow(cframe_flags_allocs)

	var clst_fb_idx_allocs *cgoAllocMap
	ref35811db8.lst_fb_idx, clst_fb_idx_allocs = *(*[5]C.int)(unsafe.Pointer(&x.LstFbIDX)), cgoAllocsUnknown
	allocs35811db8.Borrow(clst_fb_idx_allocs)

	var cgld_fb_idx_allocs *cgoAllocMap
	ref35811db8.gld_fb_idx, cgld_fb_idx_allocs = *(*[5]C.int)(unsafe.Pointer(&x.GldFbIDX)), cgoAllocsUnknown
	allocs35811db8.Borrow(cgld_fb_idx_allocs)

	var calt_fb_idx_allocs *cgoAllocMap
	ref35811db8.alt_fb_idx, calt_fb_idx_allocs = *(*[5]C.int)(unsafe.Pointer(&x.AltFbIDX)), cgoAllocsUnknown
	allocs35811db8.Borrow(calt_fb_idx_allocs)

	x.ref35811db8 = ref35811db8
	x.allocs35811db8 = allocs35811db8
	return ref35811db8, allocs35811db8

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SvcRefFrameConfig) PassValue() (value C.vpx_svc_ref_frame_config_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewSvcRefFrameConfigRef(nil)
	} else if x.ref35811db8 != nil {
		return *x.ref35811db8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SvcRefFrameConfig) Deref() {
	if x.ref35811db8 == nil {
		return
	}
	x.FrameFlags = *(*[5]int)(unsafe.Pointer(&x.ref35811db8.frame_flags))
	x.LstFbIDX = *(*[5]int)(unsafe.Pointer(&x.ref35811db8.lst_fb_idx))
	x.GldFbIDX = *(*[5]int)(unsafe.Pointer(&x.ref35811db8.gld_fb_idx))
	x.AltFbIDX = *(*[5]int)(unsafe.Pointer(&x.ref35811db8.alt_fb_idx))
}

// allocVp8PostprocCfgMemory allocates memory for type C.vp8_postproc_cfg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVp8PostprocCfgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVp8PostprocCfgValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVp8PostprocCfgValue = unsafe.Sizeof([1]C.vp8_postproc_cfg_t{})

// Ref returns a reference.
func (x *Vp8PostprocCfg) Ref() *C.vp8_postproc_cfg_t {
	if x == nil {
		return nil
	}
	return x.refc33fa674
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Vp8PostprocCfg) Free() {
	if x != nil && x.allocsc33fa674 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsc33fa674.(*cgoAllocMap).Free()
		x.refc33fa674 = nil
	}
}

// NewVp8PostprocCfgRef initialises a new struct holding the reference to the originaitng C struct.
func NewVp8PostprocCfgRef(ref *C.vp8_postproc_cfg_t) *Vp8PostprocCfg {
	if ref == nil {
		return nil
	}
	obj := new(Vp8PostprocCfg)
	obj.refc33fa674 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *Vp8PostprocCfg) {
	// 	C.free(unsafe.Pointer(x.refc33fa674))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Vp8PostprocCfg) PassRef() (ref *C.vp8_postproc_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc33fa674 != nil {
		return x.refc33fa674, nil
	}
	memc33fa674 := allocVp8PostprocCfgMemory(1)
	refc33fa674 := (*C.vp8_postproc_cfg_t)(memc33fa674)
	allocsc33fa674 := new(cgoAllocMap)
	var cpost_proc_flag_allocs *cgoAllocMap
	refc33fa674.post_proc_flag, cpost_proc_flag_allocs = (C.int)(x.PostProcFlag), cgoAllocsUnknown
	allocsc33fa674.Borrow(cpost_proc_flag_allocs)

	var cdeblocking_level_allocs *cgoAllocMap
	refc33fa674.deblocking_level, cdeblocking_level_allocs = (C.int)(x.DeblockingLevel), cgoAllocsUnknown
	allocsc33fa674.Borrow(cdeblocking_level_allocs)

	var cnoise_level_allocs *cgoAllocMap
	refc33fa674.noise_level, cnoise_level_allocs = (C.int)(x.NoiseLevel), cgoAllocsUnknown
	allocsc33fa674.Borrow(cnoise_level_allocs)

	x.refc33fa674 = refc33fa674
	x.allocsc33fa674 = allocsc33fa674
	return refc33fa674, allocsc33fa674

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Vp8PostprocCfg) PassValue() (value C.vp8_postproc_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewVp8PostprocCfgRef(nil)
	} else if x.refc33fa674 != nil {
		return *x.refc33fa674, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Vp8PostprocCfg) Deref() {
	if x.refc33fa674 == nil {
		return
	}
	x.PostProcFlag = (int)(x.refc33fa674.post_proc_flag)
	x.DeblockingLevel = (int)(x.refc33fa674.deblocking_level)
	x.NoiseLevel = (int)(x.refc33fa674.noise_level)
}

// allocRefFrameMemory allocates memory for type C.vpx_ref_frame_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRefFrameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRefFrameValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRefFrameValue = unsafe.Sizeof([1]C.vpx_ref_frame_t{})

// Ref returns a reference.
func (x *RefFrame) Ref() *C.vpx_ref_frame_t {
	if x == nil {
		return nil
	}
	return x.ref6238b069
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *RefFrame) Free() {
	if x != nil && x.allocs6238b069 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs6238b069.(*cgoAllocMap).Free()
		x.ref6238b069 = nil
	}
}

// NewRefFrameRef initialises a new struct holding the reference to the originaitng C struct.
func NewRefFrameRef(ref *C.vpx_ref_frame_t) *RefFrame {
	if ref == nil {
		return nil
	}
	obj := new(RefFrame)
	obj.ref6238b069 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *RefFrame) {
	// 	C.free(unsafe.Pointer(x.ref6238b069))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *RefFrame) PassRef() (ref *C.vpx_ref_frame_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6238b069 != nil {
		return x.ref6238b069, nil
	}
	mem6238b069 := allocRefFrameMemory(1)
	ref6238b069 := (*C.vpx_ref_frame_t)(mem6238b069)
	allocs6238b069 := new(cgoAllocMap)
	var cframe_type_allocs *cgoAllocMap
	ref6238b069.frame_type, cframe_type_allocs = (C.vpx_ref_frame_type_t)(x.FrameType), cgoAllocsUnknown
	allocs6238b069.Borrow(cframe_type_allocs)

	var cimg_allocs *cgoAllocMap
	ref6238b069.img, cimg_allocs = x.Img.PassValue()
	allocs6238b069.Borrow(cimg_allocs)

	x.ref6238b069 = ref6238b069
	x.allocs6238b069 = allocs6238b069
	return ref6238b069, allocs6238b069

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *RefFrame) PassValue() (value C.vpx_ref_frame_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewRefFrameRef(nil)
	} else if x.ref6238b069 != nil {
		return *x.ref6238b069, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *RefFrame) Deref() {
	if x.ref6238b069 == nil {
		return
	}
	x.FrameType = (RefFrameType)(x.ref6238b069.frame_type)
	x.Img = *NewImageRef(&x.ref6238b069.img)
}

// allocVp9RefFrameMemory allocates memory for type C.vp9_ref_frame_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVp9RefFrameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVp9RefFrameValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVp9RefFrameValue = unsafe.Sizeof([1]C.vp9_ref_frame_t{})

// Ref returns a reference.
func (x *Vp9RefFrame) Ref() *C.vp9_ref_frame_t {
	if x == nil {
		return nil
	}
	return x.ref223f847
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Vp9RefFrame) Free() {
	if x != nil && x.allocs223f847 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs223f847.(*cgoAllocMap).Free()
		x.ref223f847 = nil
	}
}

// NewVp9RefFrameRef initialises a new struct holding the reference to the originaitng C struct.
func NewVp9RefFrameRef(ref *C.vp9_ref_frame_t) *Vp9RefFrame {
	if ref == nil {
		return nil
	}
	obj := new(Vp9RefFrame)
	obj.ref223f847 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *Vp9RefFrame) {
	// 	C.free(unsafe.Pointer(x.ref223f847))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Vp9RefFrame) PassRef() (ref *C.vp9_ref_frame_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref223f847 != nil {
		return x.ref223f847, nil
	}
	mem223f847 := allocVp9RefFrameMemory(1)
	ref223f847 := (*C.vp9_ref_frame_t)(mem223f847)
	allocs223f847 := new(cgoAllocMap)
	var cidx_allocs *cgoAllocMap
	ref223f847.idx, cidx_allocs = (C.int)(x.Idx), cgoAllocsUnknown
	allocs223f847.Borrow(cidx_allocs)

	var cimg_allocs *cgoAllocMap
	ref223f847.img, cimg_allocs = x.Img.PassValue()
	allocs223f847.Borrow(cimg_allocs)

	x.ref223f847 = ref223f847
	x.allocs223f847 = allocs223f847
	return ref223f847, allocs223f847

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Vp9RefFrame) PassValue() (value C.vp9_ref_frame_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewVp9RefFrameRef(nil)
	} else if x.ref223f847 != nil {
		return *x.ref223f847, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Vp9RefFrame) Deref() {
	if x.ref223f847 == nil {
		return
	}
	x.Idx = (int)(x.ref223f847.idx)
	x.Img = *NewImageRef(&x.ref223f847.img)
}

// allocCodecCtxMemory allocates memory for type C.vpx_codec_ctx_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecCtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecCtxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecCtxValue = unsafe.Sizeof([1]C.vpx_codec_ctx_t{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns a reference.
func (x *CodecCtx) Ref() *C.vpx_codec_ctx_t {
	if x == nil {
		return nil
	}
	return x.ref8abc1e81
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CodecCtx) Free() {
	if x != nil && x.allocs8abc1e81 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs8abc1e81.(*cgoAllocMap).Free()
		x.ref8abc1e81 = nil
	}
}

// NewCodecCtxRef initialises a new struct holding the reference to the originaitng C struct.
func NewCodecCtxRef(ref *C.vpx_codec_ctx_t) *CodecCtx {
	if ref == nil {
		return nil
	}
	obj := new(CodecCtx)
	obj.ref8abc1e81 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *CodecCtx) {
	// 	C.free(unsafe.Pointer(x.ref8abc1e81))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CodecCtx) PassRef() (ref *C.vpx_codec_ctx_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8abc1e81 != nil {
		return x.ref8abc1e81, nil
	}
	mem8abc1e81 := allocCodecCtxMemory(1)
	ref8abc1e81 := (*C.vpx_codec_ctx_t)(mem8abc1e81)
	allocs8abc1e81 := new(cgoAllocMap)
	var cname_allocs *cgoAllocMap
	ref8abc1e81.name, cname_allocs = unpackPCharString(x.Name)
	allocs8abc1e81.Borrow(cname_allocs)

	var ciface_allocs *cgoAllocMap
	ref8abc1e81.iface, ciface_allocs = (*C.vpx_codec_iface_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Iface)).Data)), cgoAllocsUnknown
	allocs8abc1e81.Borrow(ciface_allocs)

	var cerr_allocs *cgoAllocMap
	ref8abc1e81.err, cerr_allocs = (C.vpx_codec_err_t)(x.Err), cgoAllocsUnknown
	allocs8abc1e81.Borrow(cerr_allocs)

	var cerr_detail_allocs *cgoAllocMap
	ref8abc1e81.err_detail, cerr_detail_allocs = unpackPCharString(x.ErrDetail)
	allocs8abc1e81.Borrow(cerr_detail_allocs)

	var cinit_flags_allocs *cgoAllocMap
	ref8abc1e81.init_flags, cinit_flags_allocs = (C.vpx_codec_flags_t)(x.InitFlags), cgoAllocsUnknown
	allocs8abc1e81.Borrow(cinit_flags_allocs)

	var cconfig_allocs *cgoAllocMap
	ref8abc1e81.config, cconfig_allocs = *(*[8]byte)(unsafe.Pointer(&x.Config)), cgoAllocsUnknown
	allocs8abc1e81.Borrow(cconfig_allocs)

	var cpriv_allocs *cgoAllocMap
	ref8abc1e81.priv, cpriv_allocs = (*C.vpx_codec_priv_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Priv)).Data)), cgoAllocsUnknown
	allocs8abc1e81.Borrow(cpriv_allocs)

	x.ref8abc1e81 = ref8abc1e81
	x.allocs8abc1e81 = allocs8abc1e81
	return ref8abc1e81, allocs8abc1e81

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CodecCtx) PassValue() (value C.vpx_codec_ctx_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewCodecCtxRef(nil)
	} else if x.ref8abc1e81 != nil {
		return *x.ref8abc1e81, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CodecCtx) Deref() {
	if x.ref8abc1e81 == nil {
		return
	}
	x.Name = packPCharString(x.ref8abc1e81.name)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Iface))
	hxff2234b.Data = uintptr(unsafe.Pointer(x.ref8abc1e81.iface))
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.Err = (CodecErr)(x.ref8abc1e81.err)
	x.ErrDetail = packPCharString(x.ref8abc1e81.err_detail)
	x.InitFlags = (CodecFlags)(x.ref8abc1e81.init_flags)
	x.Config = *(*[8]byte)(unsafe.Pointer(&x.ref8abc1e81.config))
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.Priv))
	hxff73280.Data = uintptr(unsafe.Pointer(x.ref8abc1e81.priv))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

}

// allocImageMemory allocates memory for type C.vpx_image_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.vpx_image_t{})

// allocA4PUcharMemory allocates memory for type [4]*C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA4PUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA4PUcharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA4PUcharValue = unsafe.Sizeof([1][4]*C.uchar{})

// unpackA4SByte transforms a sliced Go data structure into plain C format.
func unpackA4SByte(x [4][]byte) (unpacked [4]*C.uchar, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.uchar) {
		go allocs.Free()
	})

	mem0 := allocA4PUcharMemory(1)
	allocs.Add(mem0)
	v0 := (*[4]*C.uchar)(mem0)
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uchar)(unsafe.Pointer(h.Data))
	}
	unpacked = *(*[4]*C.uchar)(mem0)
	return
}

// packA4SByte reads sliced Go data structure out from plain C format.
func packA4SByte(v *[4][]byte, ptr0 *[4]*C.uchar) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := ptr0[i0]
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfa9955c.Data = uintptr(unsafe.Pointer(ptr1))
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?
	}
}

// Ref returns a reference.
func (x *Image) Ref() *C.vpx_image_t {
	if x == nil {
		return nil
	}
	return x.refc09455e3
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Image) Free() {
	if x != nil && x.allocsc09455e3 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsc09455e3.(*cgoAllocMap).Free()
		x.refc09455e3 = nil
	}
}

// NewImageRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageRef(ref *C.vpx_image_t) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.refc09455e3 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *Image) {
	// 	C.free(unsafe.Pointer(x.refc09455e3))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Image) PassRef() (ref *C.vpx_image_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc09455e3 != nil {
		return x.refc09455e3, nil
	}
	memc09455e3 := allocImageMemory(1)
	refc09455e3 := (*C.vpx_image_t)(memc09455e3)
	allocsc09455e3 := new(cgoAllocMap)
	var cfmt_allocs *cgoAllocMap
	refc09455e3.fmt, cfmt_allocs = (C.vpx_img_fmt_t)(x.Fmt), cgoAllocsUnknown
	allocsc09455e3.Borrow(cfmt_allocs)

	var ccs_allocs *cgoAllocMap
	refc09455e3.cs, ccs_allocs = (C.vpx_color_space_t)(x.Cs), cgoAllocsUnknown
	allocsc09455e3.Borrow(ccs_allocs)

	var c_range_allocs *cgoAllocMap
	refc09455e3._range, c_range_allocs = (C.vpx_color_range_t)(x.Range), cgoAllocsUnknown
	allocsc09455e3.Borrow(c_range_allocs)

	var cw_allocs *cgoAllocMap
	refc09455e3.w, cw_allocs = (C.uint)(x.W), cgoAllocsUnknown
	allocsc09455e3.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refc09455e3.h, ch_allocs = (C.uint)(x.H), cgoAllocsUnknown
	allocsc09455e3.Borrow(ch_allocs)

	var cbit_depth_allocs *cgoAllocMap
	refc09455e3.bit_depth, cbit_depth_allocs = (C.uint)(x.BitDepth), cgoAllocsUnknown
	allocsc09455e3.Borrow(cbit_depth_allocs)

	var cd_w_allocs *cgoAllocMap
	refc09455e3.d_w, cd_w_allocs = (C.uint)(x.DW), cgoAllocsUnknown
	allocsc09455e3.Borrow(cd_w_allocs)

	var cd_h_allocs *cgoAllocMap
	refc09455e3.d_h, cd_h_allocs = (C.uint)(x.DH), cgoAllocsUnknown
	allocsc09455e3.Borrow(cd_h_allocs)

	var cr_w_allocs *cgoAllocMap
	refc09455e3.r_w, cr_w_allocs = (C.uint)(x.RW), cgoAllocsUnknown
	allocsc09455e3.Borrow(cr_w_allocs)

	var cr_h_allocs *cgoAllocMap
	refc09455e3.r_h, cr_h_allocs = (C.uint)(x.RH), cgoAllocsUnknown
	allocsc09455e3.Borrow(cr_h_allocs)

	var cx_chroma_shift_allocs *cgoAllocMap
	refc09455e3.x_chroma_shift, cx_chroma_shift_allocs = (C.uint)(x.XChromaShift), cgoAllocsUnknown
	allocsc09455e3.Borrow(cx_chroma_shift_allocs)

	var cy_chroma_shift_allocs *cgoAllocMap
	refc09455e3.y_chroma_shift, cy_chroma_shift_allocs = (C.uint)(x.YChromaShift), cgoAllocsUnknown
	allocsc09455e3.Borrow(cy_chroma_shift_allocs)

	var cplanes_allocs *cgoAllocMap
	refc09455e3.planes, cplanes_allocs = unpackA4SByte(x.Planes)
	allocsc09455e3.Borrow(cplanes_allocs)

	var cstride_allocs *cgoAllocMap
	refc09455e3.stride, cstride_allocs = *(*[4]C.int)(unsafe.Pointer(&x.Stride)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cstride_allocs)

	var cbps_allocs *cgoAllocMap
	refc09455e3.bps, cbps_allocs = (C.int)(x.Bps), cgoAllocsUnknown
	allocsc09455e3.Borrow(cbps_allocs)

	var cuser_priv_allocs *cgoAllocMap
	refc09455e3.user_priv, cuser_priv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.UserPriv)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cuser_priv_allocs)

	var cimg_data_allocs *cgoAllocMap
	refc09455e3.img_data, cimg_data_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.ImgData)).Data)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cimg_data_allocs)

	var cimg_data_owner_allocs *cgoAllocMap
	refc09455e3.img_data_owner, cimg_data_owner_allocs = (C.int)(x.ImgDataOwner), cgoAllocsUnknown
	allocsc09455e3.Borrow(cimg_data_owner_allocs)

	var cself_allocd_allocs *cgoAllocMap
	refc09455e3.self_allocd, cself_allocd_allocs = (C.int)(x.SelfAllocd), cgoAllocsUnknown
	allocsc09455e3.Borrow(cself_allocd_allocs)

	var cfb_priv_allocs *cgoAllocMap
	refc09455e3.fb_priv, cfb_priv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.FbPriv)), cgoAllocsUnknown
	allocsc09455e3.Borrow(cfb_priv_allocs)

	x.refc09455e3 = refc09455e3
	x.allocsc09455e3 = allocsc09455e3
	return refc09455e3, allocsc09455e3

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Image) PassValue() (value C.vpx_image_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewImageRef(nil)
	} else if x.refc09455e3 != nil {
		return *x.refc09455e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Image) Deref() {
	if x.refc09455e3 == nil {
		return
	}
	x.Fmt = (ImageFormat)(x.refc09455e3.fmt)
	x.Cs = (ColorSpace)(x.refc09455e3.cs)
	x.Range = (ColorRange)(x.refc09455e3._range)
	x.W = (uint)(x.refc09455e3.w)
	x.H = (uint)(x.refc09455e3.h)
	x.BitDepth = (uint)(x.refc09455e3.bit_depth)
	x.DW = (uint)(x.refc09455e3.d_w)
	x.DH = (uint)(x.refc09455e3.d_h)
	x.RW = (uint)(x.refc09455e3.r_w)
	x.RH = (uint)(x.refc09455e3.r_h)
	x.XChromaShift = (uint)(x.refc09455e3.x_chroma_shift)
	x.YChromaShift = (uint)(x.refc09455e3.y_chroma_shift)
	packA4SByte(&x.Planes, (*[4]*C.uchar)(unsafe.Pointer(&x.refc09455e3.planes)))
	x.Stride = *(*[4]int)(unsafe.Pointer(&x.refc09455e3.stride))
	x.Bps = (int)(x.refc09455e3.bps)
	x.UserPriv = (unsafe.Pointer)(unsafe.Pointer(x.refc09455e3.user_priv))
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.ImgData))
	hxfa3f05c.Data = uintptr(unsafe.Pointer(x.refc09455e3.img_data))
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.ImgDataOwner = (int)(x.refc09455e3.img_data_owner)
	x.SelfAllocd = (int)(x.refc09455e3.self_allocd)
	x.FbPriv = (unsafe.Pointer)(unsafe.Pointer(x.refc09455e3.fb_priv))
}

// allocImageRectMemory allocates memory for type C.vpx_image_rect_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageRectValue = unsafe.Sizeof([1]C.vpx_image_rect_t{})

// Ref returns a reference.
func (x *ImageRect) Ref() *C.vpx_image_rect_t {
	if x == nil {
		return nil
	}
	return x.reff3ce051f
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *ImageRect) Free() {
	if x != nil && x.allocsf3ce051f != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsf3ce051f.(*cgoAllocMap).Free()
		x.reff3ce051f = nil
	}
}

// NewImageRectRef initialises a new struct holding the reference to the originaitng C struct.
func NewImageRectRef(ref *C.vpx_image_rect_t) *ImageRect {
	if ref == nil {
		return nil
	}
	obj := new(ImageRect)
	obj.reff3ce051f = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *ImageRect) {
	// 	C.free(unsafe.Pointer(x.reff3ce051f))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *ImageRect) PassRef() (ref *C.vpx_image_rect_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3ce051f != nil {
		return x.reff3ce051f, nil
	}
	memf3ce051f := allocImageRectMemory(1)
	reff3ce051f := (*C.vpx_image_rect_t)(memf3ce051f)
	allocsf3ce051f := new(cgoAllocMap)
	var cx_allocs *cgoAllocMap
	reff3ce051f.x, cx_allocs = (C.uint)(x.X), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	reff3ce051f.y, cy_allocs = (C.uint)(x.Y), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	reff3ce051f.w, cw_allocs = (C.uint)(x.W), cgoAllocsUnknown
	allocsf3ce051f.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	reff3ce051f.h, ch_allocs = (C.uint)(x.H), cgoAllocsUnknown
	allocsf3ce051f.Borrow(ch_allocs)

	x.reff3ce051f = reff3ce051f
	x.allocsf3ce051f = allocsf3ce051f
	return reff3ce051f, allocsf3ce051f

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *ImageRect) PassValue() (value C.vpx_image_rect_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewImageRectRef(nil)
	} else if x.reff3ce051f != nil {
		return *x.reff3ce051f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *ImageRect) Deref() {
	if x.reff3ce051f == nil {
		return
	}
	x.X = (uint)(x.reff3ce051f.x)
	x.Y = (uint)(x.reff3ce051f.y)
	x.W = (uint)(x.reff3ce051f.w)
	x.H = (uint)(x.reff3ce051f.h)
}

// allocFixedBufMemory allocates memory for type C.vpx_fixed_buf_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFixedBufMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFixedBufValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFixedBufValue = unsafe.Sizeof([1]C.vpx_fixed_buf_t{})

// Ref returns a reference.
func (x *FixedBuf) Ref() *C.vpx_fixed_buf_t {
	if x == nil {
		return nil
	}
	return x.refeac28dc0
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *FixedBuf) Free() {
	if x != nil && x.allocseac28dc0 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocseac28dc0.(*cgoAllocMap).Free()
		x.refeac28dc0 = nil
	}
}

// NewFixedBufRef initialises a new struct holding the reference to the originaitng C struct.
func NewFixedBufRef(ref *C.vpx_fixed_buf_t) *FixedBuf {
	if ref == nil {
		return nil
	}
	obj := new(FixedBuf)
	obj.refeac28dc0 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *FixedBuf) {
	// 	C.free(unsafe.Pointer(x.refeac28dc0))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *FixedBuf) PassRef() (ref *C.vpx_fixed_buf_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeac28dc0 != nil {
		return x.refeac28dc0, nil
	}
	memeac28dc0 := allocFixedBufMemory(1)
	refeac28dc0 := (*C.vpx_fixed_buf_t)(memeac28dc0)
	allocseac28dc0 := new(cgoAllocMap)
	var cbuf_allocs *cgoAllocMap
	refeac28dc0.buf, cbuf_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Buf)), cgoAllocsUnknown
	allocseac28dc0.Borrow(cbuf_allocs)

	var csz_allocs *cgoAllocMap
	refeac28dc0.sz, csz_allocs = (C.size_t)(x.Sz), cgoAllocsUnknown
	allocseac28dc0.Borrow(csz_allocs)

	x.refeac28dc0 = refeac28dc0
	x.allocseac28dc0 = allocseac28dc0
	return refeac28dc0, allocseac28dc0

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *FixedBuf) PassValue() (value C.vpx_fixed_buf_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewFixedBufRef(nil)
	} else if x.refeac28dc0 != nil {
		return *x.refeac28dc0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *FixedBuf) Deref() {
	if x.refeac28dc0 == nil {
		return
	}
	x.Buf = (unsafe.Pointer)(unsafe.Pointer(x.refeac28dc0.buf))
	x.Sz = (uint)(x.refeac28dc0.sz)
}

// allocCodecCxPktMemory allocates memory for type C.vpx_codec_cx_pkt_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecCxPktMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecCxPktValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecCxPktValue = unsafe.Sizeof([1]C.vpx_codec_cx_pkt_t{})

// Ref returns a reference.
func (x *CodecCxPkt) Ref() *C.vpx_codec_cx_pkt_t {
	if x == nil {
		return nil
	}
	return x.refa671fc83
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CodecCxPkt) Free() {
	if x != nil && x.allocsa671fc83 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsa671fc83.(*cgoAllocMap).Free()
		x.refa671fc83 = nil
	}
}

// NewCodecCxPktRef initialises a new struct holding the reference to the originaitng C struct.
func NewCodecCxPktRef(ref *C.vpx_codec_cx_pkt_t) *CodecCxPkt {
	if ref == nil {
		return nil
	}
	obj := new(CodecCxPkt)
	obj.refa671fc83 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *CodecCxPkt) {
	// 	C.free(unsafe.Pointer(x.refa671fc83))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CodecCxPkt) PassRef() (ref *C.vpx_codec_cx_pkt_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa671fc83 != nil {
		return x.refa671fc83, nil
	}
	mema671fc83 := allocCodecCxPktMemory(1)
	refa671fc83 := (*C.vpx_codec_cx_pkt_t)(mema671fc83)
	allocsa671fc83 := new(cgoAllocMap)
	var ckind_allocs *cgoAllocMap
	refa671fc83.kind, ckind_allocs = (C.enum_vpx_codec_cx_pkt_kind)(x.Kind), cgoAllocsUnknown
	allocsa671fc83.Borrow(ckind_allocs)

	var cdata_allocs *cgoAllocMap
	refa671fc83.data, cdata_allocs = *(*[128]byte)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocsa671fc83.Borrow(cdata_allocs)

	x.refa671fc83 = refa671fc83
	x.allocsa671fc83 = allocsa671fc83
	return refa671fc83, allocsa671fc83

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CodecCxPkt) PassValue() (value C.vpx_codec_cx_pkt_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewCodecCxPktRef(nil)
	} else if x.refa671fc83 != nil {
		return *x.refa671fc83, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CodecCxPkt) Deref() {
	if x.refa671fc83 == nil {
		return
	}
	x.Kind = (CodecCxPktKind)(x.refa671fc83.kind)
	x.Data = *(*[128]byte)(unsafe.Pointer(&x.refa671fc83.data))
}

// packSCodecCxPkt reads sliced Go data structure out from plain C format.
func packSCodecCxPkt(v []CodecCxPkt, ptr0 *C.vpx_codec_cx_pkt_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]C.vpx_codec_cx_pkt_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCodecCxPktRef(&ptr1)
	}
}

// PassRef returns a reference.
func (x CodecEncOutputCxPktCbFn) PassRef() (ref C.vpx_codec_enc_output_cx_pkt_cb_fn_t, allocs *cgoAllocMap) {
	if codecEncOutputCxPktCbFnF619E593Func == nil {
		codecEncOutputCxPktCbFnF619E593Func = x
	}
	return (C.vpx_codec_enc_output_cx_pkt_cb_fn_t)(C.vpx_codec_enc_output_cx_pkt_cb_fn_t_f619e593), nil
}

//export codecEncOutputCxPktCbFnF619E593
func codecEncOutputCxPktCbFnF619E593(cpkt *C.vpx_codec_cx_pkt_t, cuserData unsafe.Pointer) {
	if codecEncOutputCxPktCbFnF619E593Func != nil {
		var pkt []CodecCxPkt
		packSCodecCxPkt(pkt, cpkt)
		userData := (unsafe.Pointer)(unsafe.Pointer(cuserData))
		codecEncOutputCxPktCbFnF619E593Func(pkt, userData)
	}
	panic("callback func has not been set (race?)")
}

var codecEncOutputCxPktCbFnF619E593Func CodecEncOutputCxPktCbFn

// allocCodecPrivOutputCxPktCbPairMemory allocates memory for type C.vpx_codec_priv_output_cx_pkt_cb_pair_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecPrivOutputCxPktCbPairMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecPrivOutputCxPktCbPairValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecPrivOutputCxPktCbPairValue = unsafe.Sizeof([1]C.vpx_codec_priv_output_cx_pkt_cb_pair_t{})

// Ref returns a reference.
func (x *CodecPrivOutputCxPktCbPair) Ref() *C.vpx_codec_priv_output_cx_pkt_cb_pair_t {
	if x == nil {
		return nil
	}
	return x.ref5727a29d
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CodecPrivOutputCxPktCbPair) Free() {
	if x != nil && x.allocs5727a29d != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs5727a29d.(*cgoAllocMap).Free()
		x.ref5727a29d = nil
	}
}

// NewCodecPrivOutputCxPktCbPairRef initialises a new struct holding the reference to the originaitng C struct.
func NewCodecPrivOutputCxPktCbPairRef(ref *C.vpx_codec_priv_output_cx_pkt_cb_pair_t) *CodecPrivOutputCxPktCbPair {
	if ref == nil {
		return nil
	}
	obj := new(CodecPrivOutputCxPktCbPair)
	obj.ref5727a29d = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *CodecPrivOutputCxPktCbPair) {
	// 	C.free(unsafe.Pointer(x.ref5727a29d))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CodecPrivOutputCxPktCbPair) PassRef() (ref *C.vpx_codec_priv_output_cx_pkt_cb_pair_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5727a29d != nil {
		return x.ref5727a29d, nil
	}
	mem5727a29d := allocCodecPrivOutputCxPktCbPairMemory(1)
	ref5727a29d := (*C.vpx_codec_priv_output_cx_pkt_cb_pair_t)(mem5727a29d)
	allocs5727a29d := new(cgoAllocMap)
	var coutput_cx_pkt_allocs *cgoAllocMap
	ref5727a29d.output_cx_pkt, coutput_cx_pkt_allocs = x.OutputCxPkt.PassRef()
	allocs5727a29d.Borrow(coutput_cx_pkt_allocs)

	var cuser_priv_allocs *cgoAllocMap
	ref5727a29d.user_priv, cuser_priv_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.UserPriv)), cgoAllocsUnknown
	allocs5727a29d.Borrow(cuser_priv_allocs)

	x.ref5727a29d = ref5727a29d
	x.allocs5727a29d = allocs5727a29d
	return ref5727a29d, allocs5727a29d

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CodecPrivOutputCxPktCbPair) PassValue() (value C.vpx_codec_priv_output_cx_pkt_cb_pair_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewCodecPrivOutputCxPktCbPairRef(nil)
	} else if x.ref5727a29d != nil {
		return *x.ref5727a29d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CodecPrivOutputCxPktCbPair) Deref() {
	if x.ref5727a29d == nil {
		return
	}
	// x.OutputCxPkt is a callback func
	x.UserPriv = (unsafe.Pointer)(unsafe.Pointer(x.ref5727a29d.user_priv))
}

// allocRationalMemory allocates memory for type C.vpx_rational_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRationalMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRationalValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRationalValue = unsafe.Sizeof([1]C.vpx_rational_t{})

// Ref returns a reference.
func (x *Rational) Ref() *C.vpx_rational_t {
	if x == nil {
		return nil
	}
	return x.ref48ce5779
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *Rational) Free() {
	if x != nil && x.allocs48ce5779 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs48ce5779.(*cgoAllocMap).Free()
		x.ref48ce5779 = nil
	}
}

// NewRationalRef initialises a new struct holding the reference to the originaitng C struct.
func NewRationalRef(ref *C.vpx_rational_t) *Rational {
	if ref == nil {
		return nil
	}
	obj := new(Rational)
	obj.ref48ce5779 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *Rational) {
	// 	C.free(unsafe.Pointer(x.ref48ce5779))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *Rational) PassRef() (ref *C.vpx_rational_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48ce5779 != nil {
		return x.ref48ce5779, nil
	}
	mem48ce5779 := allocRationalMemory(1)
	ref48ce5779 := (*C.vpx_rational_t)(mem48ce5779)
	allocs48ce5779 := new(cgoAllocMap)
	var cnum_allocs *cgoAllocMap
	ref48ce5779.num, cnum_allocs = (C.int)(x.Num), cgoAllocsUnknown
	allocs48ce5779.Borrow(cnum_allocs)

	var cden_allocs *cgoAllocMap
	ref48ce5779.den, cden_allocs = (C.int)(x.Den), cgoAllocsUnknown
	allocs48ce5779.Borrow(cden_allocs)

	x.ref48ce5779 = ref48ce5779
	x.allocs48ce5779 = allocs48ce5779
	return ref48ce5779, allocs48ce5779

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *Rational) PassValue() (value C.vpx_rational_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewRationalRef(nil)
	} else if x.ref48ce5779 != nil {
		return *x.ref48ce5779, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *Rational) Deref() {
	if x.ref48ce5779 == nil {
		return
	}
	x.Num = (int)(x.ref48ce5779.num)
	x.Den = (int)(x.ref48ce5779.den)
}

// allocCodecEncCfgMemory allocates memory for type C.vpx_codec_enc_cfg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCodecEncCfgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCodecEncCfgValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCodecEncCfgValue = unsafe.Sizeof([1]C.vpx_codec_enc_cfg_t{})

// Ref returns a reference.
func (x *CodecEncCfg) Ref() *C.vpx_codec_enc_cfg_t {
	if x == nil {
		return nil
	}
	return x.ref37e25db9
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *CodecEncCfg) Free() {
	if x != nil && x.allocs37e25db9 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs37e25db9.(*cgoAllocMap).Free()
		x.ref37e25db9 = nil
	}
}

// NewCodecEncCfgRef initialises a new struct holding the reference to the originaitng C struct.
func NewCodecEncCfgRef(ref *C.vpx_codec_enc_cfg_t) *CodecEncCfg {
	if ref == nil {
		return nil
	}
	obj := new(CodecEncCfg)
	obj.ref37e25db9 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *CodecEncCfg) {
	// 	C.free(unsafe.Pointer(x.ref37e25db9))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *CodecEncCfg) PassRef() (ref *C.vpx_codec_enc_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37e25db9 != nil {
		return x.ref37e25db9, nil
	}
	mem37e25db9 := allocCodecEncCfgMemory(1)
	ref37e25db9 := (*C.vpx_codec_enc_cfg_t)(mem37e25db9)
	allocs37e25db9 := new(cgoAllocMap)
	var cg_usage_allocs *cgoAllocMap
	ref37e25db9.g_usage, cg_usage_allocs = (C.uint)(x.GUsage), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_usage_allocs)

	var cg_threads_allocs *cgoAllocMap
	ref37e25db9.g_threads, cg_threads_allocs = (C.uint)(x.GThreads), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_threads_allocs)

	var cg_profile_allocs *cgoAllocMap
	ref37e25db9.g_profile, cg_profile_allocs = (C.uint)(x.GProfile), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_profile_allocs)

	var cg_w_allocs *cgoAllocMap
	ref37e25db9.g_w, cg_w_allocs = (C.uint)(x.GW), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_w_allocs)

	var cg_h_allocs *cgoAllocMap
	ref37e25db9.g_h, cg_h_allocs = (C.uint)(x.GH), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_h_allocs)

	var cg_bit_depth_allocs *cgoAllocMap
	ref37e25db9.g_bit_depth, cg_bit_depth_allocs = (C.vpx_bit_depth_t)(x.GBitDepth), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_bit_depth_allocs)

	var cg_input_bit_depth_allocs *cgoAllocMap
	ref37e25db9.g_input_bit_depth, cg_input_bit_depth_allocs = (C.uint)(x.GInputBitDepth), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_input_bit_depth_allocs)

	var cg_timebase_allocs *cgoAllocMap
	ref37e25db9.g_timebase, cg_timebase_allocs = x.GTimebase.PassValue()
	allocs37e25db9.Borrow(cg_timebase_allocs)

	var cg_error_resilient_allocs *cgoAllocMap
	ref37e25db9.g_error_resilient, cg_error_resilient_allocs = (C.vpx_codec_er_flags_t)(x.GErrorResilient), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_error_resilient_allocs)

	var cg_pass_allocs *cgoAllocMap
	ref37e25db9.g_pass, cg_pass_allocs = (C.enum_vpx_enc_pass)(x.GPass), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_pass_allocs)

	var cg_lag_in_frames_allocs *cgoAllocMap
	ref37e25db9.g_lag_in_frames, cg_lag_in_frames_allocs = (C.uint)(x.GLagInFrames), cgoAllocsUnknown
	allocs37e25db9.Borrow(cg_lag_in_frames_allocs)

	var crc_dropframe_thresh_allocs *cgoAllocMap
	ref37e25db9.rc_dropframe_thresh, crc_dropframe_thresh_allocs = (C.uint)(x.RcDropframeThresh), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_dropframe_thresh_allocs)

	var crc_resize_allowed_allocs *cgoAllocMap
	ref37e25db9.rc_resize_allowed, crc_resize_allowed_allocs = (C.uint)(x.RcResizeAllowed), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_resize_allowed_allocs)

	var crc_scaled_width_allocs *cgoAllocMap
	ref37e25db9.rc_scaled_width, crc_scaled_width_allocs = (C.uint)(x.RcScaledWidth), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_scaled_width_allocs)

	var crc_scaled_height_allocs *cgoAllocMap
	ref37e25db9.rc_scaled_height, crc_scaled_height_allocs = (C.uint)(x.RcScaledHeight), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_scaled_height_allocs)

	var crc_resize_up_thresh_allocs *cgoAllocMap
	ref37e25db9.rc_resize_up_thresh, crc_resize_up_thresh_allocs = (C.uint)(x.RcResizeUpThresh), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_resize_up_thresh_allocs)

	var crc_resize_down_thresh_allocs *cgoAllocMap
	ref37e25db9.rc_resize_down_thresh, crc_resize_down_thresh_allocs = (C.uint)(x.RcResizeDownThresh), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_resize_down_thresh_allocs)

	var crc_end_usage_allocs *cgoAllocMap
	ref37e25db9.rc_end_usage, crc_end_usage_allocs = (C.enum_vpx_rc_mode)(x.RcEndUsage), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_end_usage_allocs)

	var crc_twopass_stats_in_allocs *cgoAllocMap
	ref37e25db9.rc_twopass_stats_in, crc_twopass_stats_in_allocs = x.RcTwopassStatsIn.PassValue()
	allocs37e25db9.Borrow(crc_twopass_stats_in_allocs)

	var crc_firstpass_mb_stats_in_allocs *cgoAllocMap
	ref37e25db9.rc_firstpass_mb_stats_in, crc_firstpass_mb_stats_in_allocs = x.RcFirstpassMbStatsIn.PassValue()
	allocs37e25db9.Borrow(crc_firstpass_mb_stats_in_allocs)

	var crc_target_bitrate_allocs *cgoAllocMap
	ref37e25db9.rc_target_bitrate, crc_target_bitrate_allocs = (C.uint)(x.RcTargetBitrate), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_target_bitrate_allocs)

	var crc_min_quantizer_allocs *cgoAllocMap
	ref37e25db9.rc_min_quantizer, crc_min_quantizer_allocs = (C.uint)(x.RcMinQuantizer), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_min_quantizer_allocs)

	var crc_max_quantizer_allocs *cgoAllocMap
	ref37e25db9.rc_max_quantizer, crc_max_quantizer_allocs = (C.uint)(x.RcMaxQuantizer), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_max_quantizer_allocs)

	var crc_undershoot_pct_allocs *cgoAllocMap
	ref37e25db9.rc_undershoot_pct, crc_undershoot_pct_allocs = (C.uint)(x.RcUndershootPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_undershoot_pct_allocs)

	var crc_overshoot_pct_allocs *cgoAllocMap
	ref37e25db9.rc_overshoot_pct, crc_overshoot_pct_allocs = (C.uint)(x.RcOvershootPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_overshoot_pct_allocs)

	var crc_buf_sz_allocs *cgoAllocMap
	ref37e25db9.rc_buf_sz, crc_buf_sz_allocs = (C.uint)(x.RcBufSz), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_buf_sz_allocs)

	var crc_buf_initial_sz_allocs *cgoAllocMap
	ref37e25db9.rc_buf_initial_sz, crc_buf_initial_sz_allocs = (C.uint)(x.RcBufInitialSz), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_buf_initial_sz_allocs)

	var crc_buf_optimal_sz_allocs *cgoAllocMap
	ref37e25db9.rc_buf_optimal_sz, crc_buf_optimal_sz_allocs = (C.uint)(x.RcBufOptimalSz), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_buf_optimal_sz_allocs)

	var crc_2pass_vbr_bias_pct_allocs *cgoAllocMap
	ref37e25db9.rc_2pass_vbr_bias_pct, crc_2pass_vbr_bias_pct_allocs = (C.uint)(x.Rc2passVbrBiasPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_2pass_vbr_bias_pct_allocs)

	var crc_2pass_vbr_minsection_pct_allocs *cgoAllocMap
	ref37e25db9.rc_2pass_vbr_minsection_pct, crc_2pass_vbr_minsection_pct_allocs = (C.uint)(x.Rc2passVbrMinsectionPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_2pass_vbr_minsection_pct_allocs)

	var crc_2pass_vbr_maxsection_pct_allocs *cgoAllocMap
	ref37e25db9.rc_2pass_vbr_maxsection_pct, crc_2pass_vbr_maxsection_pct_allocs = (C.uint)(x.Rc2passVbrMaxsectionPct), cgoAllocsUnknown
	allocs37e25db9.Borrow(crc_2pass_vbr_maxsection_pct_allocs)

	var ckf_mode_allocs *cgoAllocMap
	ref37e25db9.kf_mode, ckf_mode_allocs = (C.enum_vpx_kf_mode)(x.KfMode), cgoAllocsUnknown
	allocs37e25db9.Borrow(ckf_mode_allocs)

	var ckf_min_dist_allocs *cgoAllocMap
	ref37e25db9.kf_min_dist, ckf_min_dist_allocs = (C.uint)(x.KfMinDist), cgoAllocsUnknown
	allocs37e25db9.Borrow(ckf_min_dist_allocs)

	var ckf_max_dist_allocs *cgoAllocMap
	ref37e25db9.kf_max_dist, ckf_max_dist_allocs = (C.uint)(x.KfMaxDist), cgoAllocsUnknown
	allocs37e25db9.Borrow(ckf_max_dist_allocs)

	var css_number_layers_allocs *cgoAllocMap
	ref37e25db9.ss_number_layers, css_number_layers_allocs = (C.uint)(x.SsNumberLayers), cgoAllocsUnknown
	allocs37e25db9.Borrow(css_number_layers_allocs)

	var css_enable_auto_alt_ref_allocs *cgoAllocMap
	ref37e25db9.ss_enable_auto_alt_ref, css_enable_auto_alt_ref_allocs = *(*[5]C.int)(unsafe.Pointer(&x.SsEnableAutoAltRef)), cgoAllocsUnknown
	allocs37e25db9.Borrow(css_enable_auto_alt_ref_allocs)

	var css_target_bitrate_allocs *cgoAllocMap
	ref37e25db9.ss_target_bitrate, css_target_bitrate_allocs = *(*[5]C.uint)(unsafe.Pointer(&x.SsTargetBitrate)), cgoAllocsUnknown
	allocs37e25db9.Borrow(css_target_bitrate_allocs)

	var cts_number_layers_allocs *cgoAllocMap
	ref37e25db9.ts_number_layers, cts_number_layers_allocs = (C.uint)(x.TsNumberLayers), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_number_layers_allocs)

	var cts_target_bitrate_allocs *cgoAllocMap
	ref37e25db9.ts_target_bitrate, cts_target_bitrate_allocs = *(*[5]C.uint)(unsafe.Pointer(&x.TsTargetBitrate)), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_target_bitrate_allocs)

	var cts_rate_decimator_allocs *cgoAllocMap
	ref37e25db9.ts_rate_decimator, cts_rate_decimator_allocs = *(*[5]C.uint)(unsafe.Pointer(&x.TsRateDecimator)), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_rate_decimator_allocs)

	var cts_periodicity_allocs *cgoAllocMap
	ref37e25db9.ts_periodicity, cts_periodicity_allocs = (C.uint)(x.TsPeriodicity), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_periodicity_allocs)

	var cts_layer_id_allocs *cgoAllocMap
	ref37e25db9.ts_layer_id, cts_layer_id_allocs = *(*[16]C.uint)(unsafe.Pointer(&x.TsLayerID)), cgoAllocsUnknown
	allocs37e25db9.Borrow(cts_layer_id_allocs)

	var clayer_target_bitrate_allocs *cgoAllocMap
	ref37e25db9.layer_target_bitrate, clayer_target_bitrate_allocs = *(*[12]C.uint)(unsafe.Pointer(&x.LayerTargetBitrate)), cgoAllocsUnknown
	allocs37e25db9.Borrow(clayer_target_bitrate_allocs)

	var ctemporal_layering_mode_allocs *cgoAllocMap
	ref37e25db9.temporal_layering_mode, ctemporal_layering_mode_allocs = (C.int)(x.TemporalLayeringMode), cgoAllocsUnknown
	allocs37e25db9.Borrow(ctemporal_layering_mode_allocs)

	x.ref37e25db9 = ref37e25db9
	x.allocs37e25db9 = allocs37e25db9
	return ref37e25db9, allocs37e25db9

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *CodecEncCfg) PassValue() (value C.vpx_codec_enc_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewCodecEncCfgRef(nil)
	} else if x.ref37e25db9 != nil {
		return *x.ref37e25db9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *CodecEncCfg) Deref() {
	if x.ref37e25db9 == nil {
		return
	}
	x.GUsage = (uint)(x.ref37e25db9.g_usage)
	x.GThreads = (uint)(x.ref37e25db9.g_threads)
	x.GProfile = (uint)(x.ref37e25db9.g_profile)
	x.GW = (uint)(x.ref37e25db9.g_w)
	x.GH = (uint)(x.ref37e25db9.g_h)
	x.GBitDepth = (BitDepth)(x.ref37e25db9.g_bit_depth)
	x.GInputBitDepth = (uint)(x.ref37e25db9.g_input_bit_depth)
	x.GTimebase = *NewRationalRef(&x.ref37e25db9.g_timebase)
	x.GErrorResilient = (CodecErFlags)(x.ref37e25db9.g_error_resilient)
	x.GPass = (EncPass)(x.ref37e25db9.g_pass)
	x.GLagInFrames = (uint)(x.ref37e25db9.g_lag_in_frames)
	x.RcDropframeThresh = (uint)(x.ref37e25db9.rc_dropframe_thresh)
	x.RcResizeAllowed = (uint)(x.ref37e25db9.rc_resize_allowed)
	x.RcScaledWidth = (uint)(x.ref37e25db9.rc_scaled_width)
	x.RcScaledHeight = (uint)(x.ref37e25db9.rc_scaled_height)
	x.RcResizeUpThresh = (uint)(x.ref37e25db9.rc_resize_up_thresh)
	x.RcResizeDownThresh = (uint)(x.ref37e25db9.rc_resize_down_thresh)
	x.RcEndUsage = (RcMode)(x.ref37e25db9.rc_end_usage)
	x.RcTwopassStatsIn = *NewFixedBufRef(&x.ref37e25db9.rc_twopass_stats_in)
	x.RcFirstpassMbStatsIn = *NewFixedBufRef(&x.ref37e25db9.rc_firstpass_mb_stats_in)
	x.RcTargetBitrate = (uint)(x.ref37e25db9.rc_target_bitrate)
	x.RcMinQuantizer = (uint)(x.ref37e25db9.rc_min_quantizer)
	x.RcMaxQuantizer = (uint)(x.ref37e25db9.rc_max_quantizer)
	x.RcUndershootPct = (uint)(x.ref37e25db9.rc_undershoot_pct)
	x.RcOvershootPct = (uint)(x.ref37e25db9.rc_overshoot_pct)
	x.RcBufSz = (uint)(x.ref37e25db9.rc_buf_sz)
	x.RcBufInitialSz = (uint)(x.ref37e25db9.rc_buf_initial_sz)
	x.RcBufOptimalSz = (uint)(x.ref37e25db9.rc_buf_optimal_sz)
	x.Rc2passVbrBiasPct = (uint)(x.ref37e25db9.rc_2pass_vbr_bias_pct)
	x.Rc2passVbrMinsectionPct = (uint)(x.ref37e25db9.rc_2pass_vbr_minsection_pct)
	x.Rc2passVbrMaxsectionPct = (uint)(x.ref37e25db9.rc_2pass_vbr_maxsection_pct)
	x.KfMode = (KfMode)(x.ref37e25db9.kf_mode)
	x.KfMinDist = (uint)(x.ref37e25db9.kf_min_dist)
	x.KfMaxDist = (uint)(x.ref37e25db9.kf_max_dist)
	x.SsNumberLayers = (uint)(x.ref37e25db9.ss_number_layers)
	x.SsEnableAutoAltRef = *(*[5]int)(unsafe.Pointer(&x.ref37e25db9.ss_enable_auto_alt_ref))
	x.SsTargetBitrate = *(*[5]uint)(unsafe.Pointer(&x.ref37e25db9.ss_target_bitrate))
	x.TsNumberLayers = (uint)(x.ref37e25db9.ts_number_layers)
	x.TsTargetBitrate = *(*[5]uint)(unsafe.Pointer(&x.ref37e25db9.ts_target_bitrate))
	x.TsRateDecimator = *(*[5]uint)(unsafe.Pointer(&x.ref37e25db9.ts_rate_decimator))
	x.TsPeriodicity = (uint)(x.ref37e25db9.ts_periodicity)
	x.TsLayerID = *(*[16]uint)(unsafe.Pointer(&x.ref37e25db9.ts_layer_id))
	x.LayerTargetBitrate = *(*[12]uint)(unsafe.Pointer(&x.ref37e25db9.layer_target_bitrate))
	x.TemporalLayeringMode = (int)(x.ref37e25db9.temporal_layering_mode)
}

// allocSvcExtraCfgMemory allocates memory for type C.vpx_svc_extra_cfg_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSvcExtraCfgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSvcExtraCfgValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSvcExtraCfgValue = unsafe.Sizeof([1]C.vpx_svc_extra_cfg_t{})

// Ref returns a reference.
func (x *SvcExtraCfg) Ref() *C.vpx_svc_extra_cfg_t {
	if x == nil {
		return nil
	}
	return x.ref7a0d6872
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *SvcExtraCfg) Free() {
	if x != nil && x.allocs7a0d6872 != nil {
		runtime.SetFinalizer(x, nil)
		x.allocs7a0d6872.(*cgoAllocMap).Free()
		x.ref7a0d6872 = nil
	}
}

// NewSvcExtraCfgRef initialises a new struct holding the reference to the originaitng C struct.
func NewSvcExtraCfgRef(ref *C.vpx_svc_extra_cfg_t) *SvcExtraCfg {
	if ref == nil {
		return nil
	}
	obj := new(SvcExtraCfg)
	obj.ref7a0d6872 = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *SvcExtraCfg) {
	// 	C.free(unsafe.Pointer(x.ref7a0d6872))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *SvcExtraCfg) PassRef() (ref *C.vpx_svc_extra_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a0d6872 != nil {
		return x.ref7a0d6872, nil
	}
	mem7a0d6872 := allocSvcExtraCfgMemory(1)
	ref7a0d6872 := (*C.vpx_svc_extra_cfg_t)(mem7a0d6872)
	allocs7a0d6872 := new(cgoAllocMap)
	var cmax_quantizers_allocs *cgoAllocMap
	ref7a0d6872.max_quantizers, cmax_quantizers_allocs = *(*[12]C.int)(unsafe.Pointer(&x.MaxQuantizers)), cgoAllocsUnknown
	allocs7a0d6872.Borrow(cmax_quantizers_allocs)

	var cmin_quantizers_allocs *cgoAllocMap
	ref7a0d6872.min_quantizers, cmin_quantizers_allocs = *(*[12]C.int)(unsafe.Pointer(&x.MinQuantizers)), cgoAllocsUnknown
	allocs7a0d6872.Borrow(cmin_quantizers_allocs)

	var cscaling_factor_num_allocs *cgoAllocMap
	ref7a0d6872.scaling_factor_num, cscaling_factor_num_allocs = *(*[12]C.int)(unsafe.Pointer(&x.ScalingFactorNum)), cgoAllocsUnknown
	allocs7a0d6872.Borrow(cscaling_factor_num_allocs)

	var cscaling_factor_den_allocs *cgoAllocMap
	ref7a0d6872.scaling_factor_den, cscaling_factor_den_allocs = *(*[12]C.int)(unsafe.Pointer(&x.ScalingFactorDen)), cgoAllocsUnknown
	allocs7a0d6872.Borrow(cscaling_factor_den_allocs)

	var ctemporal_layering_mode_allocs *cgoAllocMap
	ref7a0d6872.temporal_layering_mode, ctemporal_layering_mode_allocs = (C.int)(x.TemporalLayeringMode), cgoAllocsUnknown
	allocs7a0d6872.Borrow(ctemporal_layering_mode_allocs)

	x.ref7a0d6872 = ref7a0d6872
	x.allocs7a0d6872 = allocs7a0d6872
	return ref7a0d6872, allocs7a0d6872

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *SvcExtraCfg) PassValue() (value C.vpx_svc_extra_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		x = NewSvcExtraCfgRef(nil)
	} else if x.ref7a0d6872 != nil {
		return *x.ref7a0d6872, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *SvcExtraCfg) Deref() {
	if x.ref7a0d6872 == nil {
		return
	}
	x.MaxQuantizers = *(*[12]int)(unsafe.Pointer(&x.ref7a0d6872.max_quantizers))
	x.MinQuantizers = *(*[12]int)(unsafe.Pointer(&x.ref7a0d6872.min_quantizers))
	x.ScalingFactorNum = *(*[12]int)(unsafe.Pointer(&x.ref7a0d6872.scaling_factor_num))
	x.ScalingFactorDen = *(*[12]int)(unsafe.Pointer(&x.ref7a0d6872.scaling_factor_den))
	x.TemporalLayeringMode = (int)(x.ref7a0d6872.temporal_layering_mode)
}

// packPUcharString creates a Go string backed by *C.uchar and avoids copying.
func packPUcharString(p *C.uchar) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// PassRef returns a reference.
func (x DecryptCb) PassRef() (ref C.vpx_decrypt_cb, allocs *cgoAllocMap) {
	if decryptCbA470BA69Func == nil {
		decryptCbA470BA69Func = x
	}
	return (C.vpx_decrypt_cb)(C.vpx_decrypt_cb_a470ba69), nil
}

//export decryptCbA470BA69
func decryptCbA470BA69(cdecryptState unsafe.Pointer, cinput *C.uchar, coutput *C.uchar, ccount C.int) {
	if decryptCbA470BA69Func != nil {
		decryptState := (unsafe.Pointer)(unsafe.Pointer(cdecryptState))
		input := packPUcharString(cinput)
		var output []byte
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&output))
		hxf0d18b7.Data = uintptr(unsafe.Pointer(coutput))
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?

		count := (int)(ccount)
		decryptCbA470BA69Func(decryptState, input, output, count)
	}
	panic("callback func has not been set (race?)")
}

var decryptCbA470BA69Func DecryptCb

// allocDecryptInitMemory allocates memory for type C.vpx_decrypt_init in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDecryptInitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDecryptInitValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDecryptInitValue = unsafe.Sizeof([1]C.vpx_decrypt_init{})

// Ref returns a reference.
func (x *DecryptInit) Ref() *C.vpx_decrypt_init {
	if x == nil {
		return nil
	}
	return x.refed394b2b
}

// Free cleanups the memory using the free stdlib function on C side.
// Does nothing if object has no pointer.
func (x *DecryptInit) Free() {
	if x != nil && x.allocsed394b2b != nil {
		runtime.SetFinalizer(x, nil)
		x.allocsed394b2b.(*cgoAllocMap).Free()
		x.refed394b2b = nil
	}
}

// NewDecryptInitRef initialises a new struct holding the reference to the originaitng C struct.
func NewDecryptInitRef(ref *C.vpx_decrypt_init) *DecryptInit {
	if ref == nil {
		return nil
	}
	obj := new(DecryptInit)
	obj.refed394b2b = ref
	// enable this if the reference is unmanaged:
	// runtime.SetFinalizer(obj, func(x *DecryptInit) {
	// 	C.free(unsafe.Pointer(x.refed394b2b))
	// })
	return obj
}

// PassRef returns a reference and creates new C object if no refernce yet.
func (x *DecryptInit) PassRef() (ref *C.vpx_decrypt_init, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed394b2b != nil {
		return x.refed394b2b, nil
	}
	memed394b2b := allocDecryptInitMemory(1)
	refed394b2b := (*C.vpx_decrypt_init)(memed394b2b)
	allocsed394b2b := new(cgoAllocMap)
	var cdecrypt_cb_allocs *cgoAllocMap
	refed394b2b.decrypt_cb, cdecrypt_cb_allocs = x.DecryptCb.PassRef()
	allocsed394b2b.Borrow(cdecrypt_cb_allocs)

	var cdecrypt_state_allocs *cgoAllocMap
	refed394b2b.decrypt_state, cdecrypt_state_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.DecryptState)), cgoAllocsUnknown
	allocsed394b2b.Borrow(cdecrypt_state_allocs)

	x.refed394b2b = refed394b2b
	x.allocsed394b2b = allocsed394b2b
	return refed394b2b, allocsed394b2b

}

// PassValue creates a new C object if no refernce yet and returns the dereferenced value.
func (x *DecryptInit) PassValue() (value C.vpx_decrypt_init, allocs *cgoAllocMap) {
	if x == nil {
		x = NewDecryptInitRef(nil)
	} else if x.refed394b2b != nil {
		return *x.refed394b2b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref reads the internal fields of struct from its C pointer.
func (x *DecryptInit) Deref() {
	if x.refed394b2b == nil {
		return
	}
	// x.DecryptCb is a callback func
	x.DecryptState = (unsafe.Pointer)(unsafe.Pointer(x.refed394b2b.decrypt_state))
}

// unpackArgSCodecCtx transforms a sliced Go data structure into plain C format.
func unpackArgSCodecCtx(x []CodecCtx) (unpacked *C.vpx_codec_ctx_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vpx_codec_ctx_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCodecCtxMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vpx_codec_ctx_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vpx_codec_ctx_t)(unsafe.Pointer(h.Data))
	return
}

// packSCodecCtx reads sliced Go data structure out from plain C format.
func packSCodecCtx(v []CodecCtx, ptr0 *C.vpx_codec_ctx_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]C.vpx_codec_ctx_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCodecCtxRef(&ptr1)
	}
}

// unpackArgSImage transforms a sliced Go data structure into plain C format.
func unpackArgSImage(x []Image) (unpacked *C.vpx_image_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vpx_image_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vpx_image_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vpx_image_t)(unsafe.Pointer(h.Data))
	return
}

// packSImage reads sliced Go data structure out from plain C format.
func packSImage(v []Image, ptr0 *C.vpx_image_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]C.vpx_image_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageRef(&ptr1)
	}
}

// unpackArgSCodecEncCfg transforms a sliced Go data structure into plain C format.
func unpackArgSCodecEncCfg(x []CodecEncCfg) (unpacked *C.vpx_codec_enc_cfg_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vpx_codec_enc_cfg_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCodecEncCfgMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vpx_codec_enc_cfg_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vpx_codec_enc_cfg_t)(unsafe.Pointer(h.Data))
	return
}

// packSCodecEncCfg reads sliced Go data structure out from plain C format.
func packSCodecEncCfg(v []CodecEncCfg, ptr0 *C.vpx_codec_enc_cfg_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]C.vpx_codec_enc_cfg_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCodecEncCfgRef(&ptr1)
	}
}

// unpackArgSRational transforms a sliced Go data structure into plain C format.
func unpackArgSRational(x []Rational) (unpacked *C.vpx_rational_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vpx_rational_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRationalMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vpx_rational_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vpx_rational_t)(unsafe.Pointer(h.Data))
	return
}

// packSRational reads sliced Go data structure out from plain C format.
func packSRational(v []Rational, ptr0 *C.vpx_rational_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]C.vpx_rational_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRationalRef(&ptr1)
	}
}

// unpackArgSFixedBuf transforms a sliced Go data structure into plain C format.
func unpackArgSFixedBuf(x []FixedBuf) (unpacked *C.vpx_fixed_buf_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.vpx_fixed_buf_t) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFixedBufMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.vpx_fixed_buf_t)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = x[i0].PassValue()
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.vpx_fixed_buf_t)(unsafe.Pointer(h.Data))
	return
}

// packSFixedBuf reads sliced Go data structure out from plain C format.
func packSFixedBuf(v []FixedBuf, ptr0 *C.vpx_fixed_buf_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m]C.vpx_fixed_buf_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFixedBufRef(&ptr1)
	}
}
